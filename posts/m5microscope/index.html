<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Using ESP32 camera module to take pictures | Sameer's Blog</title>
<meta name=keywords content="Projects"><meta name=description content="Introduction
I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well."><meta name=author content="Sameer Rahman"><link rel=canonical href=https://sameerahman24.github.io/posts/m5microscope/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://sameerahman24.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sameerahman24.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sameerahman24.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sameerahman24.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sameerahman24.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sameerahman24.github.io/posts/m5microscope/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sameerahman24.github.io/posts/m5microscope/"><meta property="og:site_name" content="Sameer's Blog"><meta property="og:title" content="Using ESP32 camera module to take pictures "><meta property="og:description" content="Introduction I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-03-13T00:00:00+00:00"><meta property="article:modified_time" content="2025-03-13T00:00:00+00:00"><meta property="article:tag" content="Projects"><meta property="og:image" content="https://i.ibb.co/d4MGc0Dr/7-DFAC958-032-B-41-E6-9087-9-E15-A0-F25-CD9.jpg"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.ibb.co/d4MGc0Dr/7-DFAC958-032-B-41-E6-9087-9-E15-A0-F25-CD9.jpg"><meta name=twitter:title content="Using ESP32 camera module to take pictures "><meta name=twitter:description content="Introduction
I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sameerahman24.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Using ESP32 camera module to take pictures ","item":"https://sameerahman24.github.io/posts/m5microscope/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Using ESP32 camera module to take pictures ","name":"Using ESP32 camera module to take pictures ","description":"Introduction I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well.\n","keywords":["Projects"],"articleBody":"Introduction I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well.\nIn this blog post, I’ll walk you through my custom ESP32 camera system, which allows remote image capture, LED indication, power management, and a simple web server interface. The system is built using an ESP32-based M5Stack TimerCAM module and leverages FreeRTOS tasks for efficient operation.\nFeatures Task-Based Image Capture: Runs a separate task for handling camera captures without blocking the main loop. Web Server: Allows users to capture images remotely and adjust camera settings. Power Management: Puts the ESP32 into deep sleep after inactivity to conserve power. Adjustable Camera Settings: Users can modify exposure and gain dynamically via web requests. Parallel Processing: Camera operations run on Core 0 while the main application logic (web server, WiFi, UI) runs on Core 1, enabling true parallelism. Non-blocking Operation: Ensures that the main application remains responsive during image capturing. Hardware Requirements M5Stack TimerCAM (or similar ESP32 camera module) Power source (Battery or USB) LED for capture indication (optional) Code Breakdown 1. Camera Configuration Firstly, I needed to configure the pins correctly using the information available in the internet. I had to tinker a bit with settings like .jpeg_quality, .frame_size and .xclk_freq_hz to find the optimal settings for the camera to function with no bugs. This is because, when using a higher resolution with minimal compression (for example .jpeg_quality = 1) the images tend to have artifacts as there were both processing and memory challenges that the device could not keep up.\n#include #include \"camera.h\" #include camera_config_t config = { .pin_pwdn = -1, // Not used on M5Stack Timer CAM .pin_reset = 15, // RESET pin .pin_xclk = 27, // XCLK pin .pin_sccb_sda = 25, // SDA pin .pin_sccb_scl = 23, // SCL pin .pin_d7 = 19, // Y9 pin .pin_d6 = 36, // Y8 pin .pin_d5 = 18, // Y7 pin .pin_d4 = 39, // Y6 pin .pin_d3 = 5, // Y5 pin .pin_d2 = 34, // Y4 pin .pin_d1 = 35, // Y3 pin .pin_d0 = 32, // Y2 pin .pin_vsync = 22, // VSYNC pin .pin_href = 26, // HREF pin .pin_pclk = 21, // PCLK pin .xclk_freq_hz = 20000000, // Frequency .ledc_timer = LEDC_TIMER_0, .ledc_channel = LEDC_CHANNEL_0, .pixel_format = PIXFORMAT_JPEG, .frame_size = FRAMESIZE_UXGA, // Resolution of image .jpeg_quality = 3, // Compression level (higher = more compression) .fb_count = 1, // Number of frame buffers in memory .grab_mode = CAMERA_GRAB_LATEST }; The problem was even more evident before I implemented multi-threading. I had to use lower camera settings to take pictures.\nThat is why I implemented it to make the camera task run separately on Core 0, handling image capture requests asynchronously. This ensures that everything else can run smoothly on Core 1. This fixed issues like sudden connection losses and crashed.\nvoid cameraTask(void *parameter) { while (true) { if (captureRequested \u0026\u0026 !captureInProgress) { captureInProgress = true; capturedFrame = esp_camera_fb_get(); captureRequested = false; captureInProgress = false; if (capturedFrame) { xSemaphoreGive(frameReadySemaphore); } } vTaskDelay(5 / portTICK_PERIOD_MS); } } 2. Web Server for Remote Access In this section, the ESP32 sets up a web server that listens on port 80, allowing remote devices to send HTTP requests to control the camera. The core function, handleCapture(), is responsible for initiating an image capture when a client accesses the /capture endpoint. Once the image is captured using our task-based method, it sends the JPEG image data as an HTTP response.\n#include #include #include \"camera.h\" AsyncWebServer server(80); void handleCapture(AsyncWebServerRequest *request) { camera_fb_t *fb = captureImage(); if (!fb) { request-\u003esend(500, \"text/plain\", \"Camera capture failed\"); return; } request-\u003esend(200, \"image/jpeg\", fb-\u003ebuf, fb-\u003elen); } The image can then be viewed and saved into the device from the web browser.\n3. Power Management Another problem I was facing was battery life. At most the device lasted for around 20 minutes. To extend battery life, the system monitors activity by seeing when was the last time /capture endpoint was accessed and enters deep sleep if it hasn’t been accessed in more than 3 minutes.\n#include \"power.h\" #include unsigned long lastCaptureTime = 0; const unsigned long inactivityTimeout = 180000; void checkInactivity() { if (millis() - lastCaptureTime \u003e= inactivityTimeout) { Serial.println(\"Entering deep sleep...\"); esp_deep_sleep_start(); } } 4. Setting Up the Web Interface The ESP32 also serves a user-friendly HTML page stored in SPIFFS, which acts as the control panel for the camera. When a client navigates to the root URL (/), the server checks for the existence of an index.html file. If found, it sends the HTML content to the client; otherwise, it returns a 404 error. This HTML interface includes various elements such as a status panel, image display, and controls (buttons and sliders) to capture images, update camera settings, and even trigger deep sleep.\nserver.on(\"/\", HTTP_GET, [](AsyncWebServerRequest *request){ if (SPIFFS.exists(\"/index.html\")) { request-\u003esend(SPIFFS, \"/index.html\", \"text/html\"); } else { request-\u003esend(404, \"text/plain\", \"File not found\"); } }); 5. Web Interface Design and Functionality The web interface is designed to provide a user-friendly experience for capturing images and adjusting camera settings. It consists of:\nA status panel displaying IP address, battery level, and countdown timer before shutdown. An image container that shows the captured image. A control panel with sliders for exposure and gain adjustment. A capture button to trigger image capture remotely. A sleep button to put the device into deep sleep manually. The interface dynamically updates battery level and countdown timer using JavaScript, making periodic requests to the ESP32 server. Users can modify exposure and gain using sliders, and the settings are applied instantly upon clicking the update button.\nConclusion While working on this I have learned a lot. From C++ to multithreading, this project has been quite rewarding. This project has helped me develop skills like problem solving and communication skills that I developed working with my supervisor in the lab.\n","wordCount":"1037","inLanguage":"en","image":"https://i.ibb.co/d4MGc0Dr/7-DFAC958-032-B-41-E6-9087-9-E15-A0-F25-CD9.jpg","datePublished":"2025-03-13T00:00:00Z","dateModified":"2025-03-13T00:00:00Z","author":{"@type":"Person","name":"Sameer Rahman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sameerahman24.github.io/posts/m5microscope/"},"publisher":{"@type":"Organization","name":"Sameer's Blog","logo":{"@type":"ImageObject","url":"https://sameerahman24.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sameerahman24.github.io/ accesskey=h title="Sameer's Blog (Alt + H)">Sameer's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sameerahman24.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://sameerahman24.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://sameerahman24.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1SuFUrEEZWXOxtCAdJXHKmv0iU6XpzuuU/view?usp=drive_link" title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sameerahman24.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sameerahman24.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Using ESP32 camera module to take pictures</h1><div class=post-meta><span title='2025-03-13 00:00:00 +0000 UTC'>March 13, 2025</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;Sameer Rahman</div></header><figure class=entry-cover><img loading=eager src=https://i.ibb.co/d4MGc0Dr/7-DFAC958-032-B-41-E6-9087-9-E15-A0-F25-CD9.jpg alt><figcaption></figcaption></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a></li><li><a href=#features aria-label=Features>Features</a></li><li><a href=#hardware-requirements aria-label="Hardware Requirements">Hardware Requirements</a></li><li><a href=#code-breakdown aria-label="Code Breakdown">Code Breakdown</a><ul><li><a href=#1-camera-configuration aria-label="1. Camera Configuration">1. Camera Configuration</a></li><li><a href=#2-web-server-for-remote-access aria-label="2. Web Server for Remote Access">2. Web Server for Remote Access</a></li><li><a href=#3-power-management aria-label="3. Power Management">3. Power Management</a></li><li><a href=#4-setting-up-the-web-interface aria-label="4. Setting Up the Web Interface">4. Setting Up the Web Interface</a></li><li><a href=#5-web-interface-design-and-functionality aria-label="5. Web Interface Design and Functionality">5. Web Interface Design and Functionality</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><h2 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h2><p>I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well.</p><p>In this blog post, I’ll walk you through my custom ESP32 camera system, which allows remote image capture, LED indication, power management, and a simple web server interface. The system is built using an ESP32-based M5Stack TimerCAM module and leverages FreeRTOS tasks for efficient operation.</p><h2 id=features>Features<a hidden class=anchor aria-hidden=true href=#features>#</a></h2><ul><li><strong>Task-Based Image Capture</strong>: Runs a separate task for handling camera captures without blocking the main loop.</li><li><strong>Web Server</strong>: Allows users to capture images remotely and adjust camera settings.</li><li><strong>Power Management</strong>: Puts the ESP32 into deep sleep after inactivity to conserve power.</li><li><strong>Adjustable Camera Settings</strong>: Users can modify exposure and gain dynamically via web requests.</li><li><strong>Parallel Processing</strong>: Camera operations run on Core 0 while the main application logic (web server, WiFi, UI) runs on Core 1, enabling true parallelism.</li><li><strong>Non-blocking Operation</strong>: Ensures that the main application remains responsive during image capturing.</li></ul><h2 id=hardware-requirements>Hardware Requirements<a hidden class=anchor aria-hidden=true href=#hardware-requirements>#</a></h2><ul><li>M5Stack TimerCAM (or similar ESP32 camera module)</li><li>Power source (Battery or USB)</li><li>LED for capture indication (optional)</li></ul><h2 id=code-breakdown>Code Breakdown<a hidden class=anchor aria-hidden=true href=#code-breakdown>#</a></h2><h3 id=1-camera-configuration>1. Camera Configuration<a hidden class=anchor aria-hidden=true href=#1-camera-configuration>#</a></h3><p>Firstly, I needed to configure the pins correctly using the information available in the internet. I had to tinker a bit with settings like <code>.jpeg_quality</code>, <code>.frame_size</code> and <code>.xclk_freq_hz</code> to find the optimal settings for the camera to function with no bugs. This is because, when using a higher resolution with minimal compression (for example <code>.jpeg_quality = 1</code>) the images tend to have artifacts as there were both processing and memory challenges that the device could not keep up.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Arduino.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;camera.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;esp_camera.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>camera_config_t config <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    .pin_pwdn <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>,        <span style=color:#75715e>// Not used on M5Stack Timer CAM
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_reset <span style=color:#f92672>=</span> <span style=color:#ae81ff>15</span>,       <span style=color:#75715e>// RESET pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_xclk <span style=color:#f92672>=</span> <span style=color:#ae81ff>27</span>,        <span style=color:#75715e>// XCLK pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_sccb_sda <span style=color:#f92672>=</span> <span style=color:#ae81ff>25</span>,    <span style=color:#75715e>// SDA pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_sccb_scl <span style=color:#f92672>=</span> <span style=color:#ae81ff>23</span>,    <span style=color:#75715e>// SCL pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d7 <span style=color:#f92672>=</span> <span style=color:#ae81ff>19</span>,          <span style=color:#75715e>// Y9 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d6 <span style=color:#f92672>=</span> <span style=color:#ae81ff>36</span>,          <span style=color:#75715e>// Y8 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d5 <span style=color:#f92672>=</span> <span style=color:#ae81ff>18</span>,          <span style=color:#75715e>// Y7 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d4 <span style=color:#f92672>=</span> <span style=color:#ae81ff>39</span>,          <span style=color:#75715e>// Y6 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d3 <span style=color:#f92672>=</span> <span style=color:#ae81ff>5</span>,           <span style=color:#75715e>// Y5 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d2 <span style=color:#f92672>=</span> <span style=color:#ae81ff>34</span>,          <span style=color:#75715e>// Y4 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d1 <span style=color:#f92672>=</span> <span style=color:#ae81ff>35</span>,          <span style=color:#75715e>// Y3 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_d0 <span style=color:#f92672>=</span> <span style=color:#ae81ff>32</span>,          <span style=color:#75715e>// Y2 pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_vsync <span style=color:#f92672>=</span> <span style=color:#ae81ff>22</span>,       <span style=color:#75715e>// VSYNC pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_href <span style=color:#f92672>=</span> <span style=color:#ae81ff>26</span>,        <span style=color:#75715e>// HREF pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .pin_pclk <span style=color:#f92672>=</span> <span style=color:#ae81ff>21</span>,        <span style=color:#75715e>// PCLK pin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    .xclk_freq_hz <span style=color:#f92672>=</span> <span style=color:#ae81ff>20000000</span>, <span style=color:#75715e>// Frequency 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .ledc_timer <span style=color:#f92672>=</span> LEDC_TIMER_0,
</span></span><span style=display:flex><span>    .ledc_channel <span style=color:#f92672>=</span> LEDC_CHANNEL_0,
</span></span><span style=display:flex><span>    .pixel_format <span style=color:#f92672>=</span> PIXFORMAT_JPEG, 
</span></span><span style=display:flex><span>    .frame_size <span style=color:#f92672>=</span> FRAMESIZE_UXGA, <span style=color:#75715e>// Resolution of image
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .jpeg_quality <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>,  <span style=color:#75715e>// Compression level (higher = more compression)         
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .fb_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>,      <span style=color:#75715e>// Number of frame buffers in memory        
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    .grab_mode <span style=color:#f92672>=</span> CAMERA_GRAB_LATEST               
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The problem was even more evident before I implemented multi-threading. I had to use lower camera settings to take pictures.</p><p>That is why I implemented it to make the camera task run separately on Core 0, handling image capture requests asynchronously. This ensures that everything else can run smoothly on Core 1. This fixed issues like sudden connection losses and crashed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>cameraTask</span>(<span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span>parameter) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (true) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (captureRequested <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span>captureInProgress) {
</span></span><span style=display:flex><span>            captureInProgress <span style=color:#f92672>=</span> true;
</span></span><span style=display:flex><span>            capturedFrame <span style=color:#f92672>=</span> esp_camera_fb_get();
</span></span><span style=display:flex><span>            captureRequested <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            captureInProgress <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (capturedFrame) {
</span></span><span style=display:flex><span>                xSemaphoreGive(frameReadySemaphore);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        vTaskDelay(<span style=color:#ae81ff>5</span> <span style=color:#f92672>/</span> portTICK_PERIOD_MS);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=2-web-server-for-remote-access>2. Web Server for Remote Access<a hidden class=anchor aria-hidden=true href=#2-web-server-for-remote-access>#</a></h3><p>In this section, the ESP32 sets up a web server that listens on port 80, allowing remote devices to send HTTP requests to control the camera. The core function, <code>handleCapture()</code>, is responsible for initiating an image capture when a client accesses the <code>/capture</code> endpoint. Once the image is captured using our task-based method, it sends the JPEG image data as an HTTP response.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;WiFi.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;ESPAsyncWebServer.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;camera.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>AsyncWebServer <span style=color:#a6e22e>server</span>(<span style=color:#ae81ff>80</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>handleCapture</span>(AsyncWebServerRequest <span style=color:#f92672>*</span>request) {
</span></span><span style=display:flex><span>    camera_fb_t <span style=color:#f92672>*</span>fb <span style=color:#f92672>=</span> captureImage();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>fb) {
</span></span><span style=display:flex><span>        request<span style=color:#f92672>-&gt;</span>send(<span style=color:#ae81ff>500</span>, <span style=color:#e6db74>&#34;text/plain&#34;</span>, <span style=color:#e6db74>&#34;Camera capture failed&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    request<span style=color:#f92672>-&gt;</span>send(<span style=color:#ae81ff>200</span>, <span style=color:#e6db74>&#34;image/jpeg&#34;</span>, fb<span style=color:#f92672>-&gt;</span>buf, fb<span style=color:#f92672>-&gt;</span>len);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The image can then be viewed and saved into the device from the web browser.</p><h3 id=3-power-management>3. Power Management<a hidden class=anchor aria-hidden=true href=#3-power-management>#</a></h3><p>Another problem I was facing was battery life. At most the device lasted for around 20 minutes. To extend battery life, the system monitors activity by seeing when was the last time /capture endpoint was accessed and enters deep sleep if it hasn&rsquo;t been accessed in more than 3 minutes.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;power.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;esp_sleep.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> lastCaptureTime <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>unsigned</span> <span style=color:#66d9ef>long</span> inactivityTimeout <span style=color:#f92672>=</span> <span style=color:#ae81ff>180000</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>checkInactivity</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (millis() <span style=color:#f92672>-</span> lastCaptureTime <span style=color:#f92672>&gt;=</span> inactivityTimeout) {
</span></span><span style=display:flex><span>        Serial.println(<span style=color:#e6db74>&#34;Entering deep sleep...&#34;</span>);
</span></span><span style=display:flex><span>        esp_deep_sleep_start();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=4-setting-up-the-web-interface>4. Setting Up the Web Interface<a hidden class=anchor aria-hidden=true href=#4-setting-up-the-web-interface>#</a></h3><p>The ESP32 also serves a user-friendly HTML page stored in SPIFFS, which acts as the control panel for the camera. When a client navigates to the root URL (<code>/</code>), the server checks for the existence of an <code>index.html</code> file. If found, it sends the HTML content to the client; otherwise, it returns a 404 error. This HTML interface includes various elements such as a status panel, image display, and controls (buttons and sliders) to capture images, update camera settings, and even trigger deep sleep.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span>server.on(<span style=color:#e6db74>&#34;/&#34;</span>, HTTP_GET, [](AsyncWebServerRequest <span style=color:#f92672>*</span>request){
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (SPIFFS.exists(<span style=color:#e6db74>&#34;/index.html&#34;</span>)) {
</span></span><span style=display:flex><span>        request<span style=color:#f92672>-&gt;</span>send(SPIFFS, <span style=color:#e6db74>&#34;/index.html&#34;</span>, <span style=color:#e6db74>&#34;text/html&#34;</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        request<span style=color:#f92672>-&gt;</span>send(<span style=color:#ae81ff>404</span>, <span style=color:#e6db74>&#34;text/plain&#34;</span>, <span style=color:#e6db74>&#34;File not found&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h3 id=5-web-interface-design-and-functionality>5. Web Interface Design and Functionality<a hidden class=anchor aria-hidden=true href=#5-web-interface-design-and-functionality>#</a></h3><p>The web interface is designed to provide a user-friendly experience for capturing images and adjusting camera settings. It consists of:</p><ul><li>A <strong>status panel</strong> displaying IP address, battery level, and countdown timer before shutdown.</li><li>An <strong>image container</strong> that shows the captured image.</li><li>A <strong>control panel</strong> with sliders for exposure and gain adjustment.</li><li>A <strong>capture button</strong> to trigger image capture remotely.</li><li>A <strong>sleep button</strong> to put the device into deep sleep manually.</li></ul><p>The interface dynamically updates battery level and countdown timer using JavaScript, making periodic requests to the ESP32 server. Users can modify exposure and gain using sliders, and the settings are applied instantly upon clicking the update button.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>While working on this I have learned a lot. From C++ to multithreading, this project has been quite rewarding. This project has helped me develop skills like problem solving and communication skills that I developed working with my supervisor in the lab.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sameerahman24.github.io/tags/projects/>Projects</a></li></ul><nav class=paginav><a class=next href=https://sameerahman24.github.io/posts/pathfinding/><span class=title>Next »</span><br><span>Developing a Path Finding Algorithm for my game</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Using ESP32 camera module to take pictures  on x" href="https://x.com/intent/tweet/?text=Using%20ESP32%20camera%20module%20to%20take%20pictures%20&amp;url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fm5microscope%2f&amp;hashtags=Projects"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using ESP32 camera module to take pictures  on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fm5microscope%2f&amp;title=Using%20ESP32%20camera%20module%20to%20take%20pictures%20&amp;summary=Using%20ESP32%20camera%20module%20to%20take%20pictures%20&amp;source=https%3a%2f%2fsameerahman24.github.io%2fposts%2fm5microscope%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Using ESP32 camera module to take pictures  on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fm5microscope%2f&title=Using%20ESP32%20camera%20module%20to%20take%20pictures%20"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© Sameer Rahman</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>