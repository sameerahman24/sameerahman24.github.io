<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Developing a Path Finding Algorithm for my game | Sameer's Blog</title>
<meta name=keywords content="Projects"><meta name=description content="Introduction
I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself."><meta name=author content="Sameer Rahman"><link rel=canonical href=https://sameerahman24.github.io/posts/pathfinding/><link crossorigin=anonymous href=/assets/css/stylesheet.f49d66caae9ea0fd43f21f29e71a8d3e284517ed770f2aa86fa012953ad3c9ef.css integrity="sha256-9J1myq6eoP1D8h8p5xqNPihFF+13Dyqob6ASlTrTye8=" rel="preload stylesheet" as=style><link rel=icon href=https://sameerahman24.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sameerahman24.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sameerahman24.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://sameerahman24.github.io/apple-touch-icon.png><link rel=mask-icon href=https://sameerahman24.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://sameerahman24.github.io/posts/pathfinding/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://sameerahman24.github.io/posts/pathfinding/"><meta property="og:site_name" content="Sameer's Blog"><meta property="og:title" content="Developing a Path Finding Algorithm for my game"><meta property="og:description" content="Introduction I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-01-21T00:00:00+00:00"><meta property="article:modified_time" content="2025-01-21T00:00:00+00:00"><meta property="article:tag" content="Projects"><meta property="og:image" content="https://i.ibb.co/27BqpS51/399700642-21618d6f-d540-4dd8-bcea-03b7ee95c217.png"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://i.ibb.co/27BqpS51/399700642-21618d6f-d540-4dd8-bcea-03b7ee95c217.png"><meta name=twitter:title content="Developing a Path Finding Algorithm for my game"><meta name=twitter:description content="Introduction
I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://sameerahman24.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Developing a Path Finding Algorithm for my game","item":"https://sameerahman24.github.io/posts/pathfinding/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Developing a Path Finding Algorithm for my game","name":"Developing a Path Finding Algorithm for my game","description":"Introduction I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself.\n","keywords":["Projects"],"articleBody":"Introduction I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself.\nUnderstanding the Ghost’s Movement The ghost moves on a grid, where its primary goal is to either chase Pac-Man or, when scared, run away from him. To decide where to move next, the ghost needs to evaluate all possible directions and choose the best one. This is where pathfinding comes in. Specifically, the ghost evaluates its potential moves using a heuristic called the Manhattan Distance.\nThe Concept of Manhattan Distance Manhattan Distance is a simple but effective way to measure the distance between two points on a grid. The term comes from the layout of streets in the Manhattan borough of New York, where streets are aligned in a grid pattern. In this system, the distance between two points is calculated by summing the absolute differences of their respective x and y coordinates.\nFor example, if the ghost is at position (2, 3) and Pac-Man is at (5, 5), the Manhattan Distance would be:\nHorizontal distance = |5 - 2| = 3 Vertical distance = |5 - 3| = 2 Total Manhattan Distance = 3 + 2 = 5\nDirections Array The ghost can move up, down, left, or right and these options are represented as:\nprivate static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; {-1, 0}: Move up {1, 0}: Move down {0, -1}: Move left {0, 1}: Move right The Pathfinding Method The main method that determines the ghost’s movement is:\nprivate int[] findBestPath(char[][] grid, int targetRow, int targetCol, boolean away) Parameters: grid: The game grid, which includes walls (‘W’), (‘c’) and (‘f) targetRow, targetCol: The position of the player away: A boolean that indicates if the ghost should move toward (false) or away from (true) the target. Return Value: The best direction (e.g., {1, 0} for moving down), or null if no valid move is found.\nMovement Logic The ghost uses the Manhattan Distance to evaluate its moves. This heuristic calculates the distance to the target as:\nFor each direction:\nThe ghost checks if moving in that direction is valid using isValidMove. It calculates the Manhattan Distance from the potential new position to the target. It selects the move with the smallest distance (to chase) or the largest distance (to run away). Supporting Methods isValidMove: Ensures the ghost doesn’t move into walls or outside the grid boundaries. isCollidingWithGhost: Prevents ghosts from colliding with each other. updateGrid: Updates the game grid to reflect the ghost’s new position. Example Walkthrough Let’s say the ghost is at (2, 3) and Pac-Man is at (5, 5):\nThe algorithm evaluates all possible moves:\nUp: (1, 3), distance = 6 Down: (3, 3), distance = 4 Left: (2, 2), distance = 6 Right: (2, 4), distance = 4 If away == false (not scared), the ghost chooses the move with the smallest distance (Down or Right).\nIf away == true (scared), the ghost chooses the move with the largest distance (Up or Left).\nPros and Cons of Greedy Best-First Search Pros: Simplicity: The algorithm is easy to implement and computationally lightweight. Speed: Evaluating only four directions makes it fast, especially on small grids. Cons: No Global Optimization: It doesn’t guarantee the shortest or most efficient path to the target. Heuristic Limitations: The Manhattan Distance works well for simple grids but may not handle complex obstacles effectively. Conclusion The Greedy Best-First Search algorithm is an excellent choice for games like Pac-Man, where simplicity and responsiveness are key. It balances efficiency with functionality, allowing ghosts to behave dynamically without requiring heavy computations. By tweaking elements like the scare duration or movement randomness, developers can fine-tune ghost behavior for an engaging player experience.\n","wordCount":"673","inLanguage":"en","image":"https://i.ibb.co/27BqpS51/399700642-21618d6f-d540-4dd8-bcea-03b7ee95c217.png","datePublished":"2025-01-21T00:00:00Z","dateModified":"2025-01-21T00:00:00Z","author":{"@type":"Person","name":"Sameer Rahman"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sameerahman24.github.io/posts/pathfinding/"},"publisher":{"@type":"Organization","name":"Sameer's Blog","logo":{"@type":"ImageObject","url":"https://sameerahman24.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sameerahman24.github.io/ accesskey=h title="Sameer's Blog (Alt + H)">Sameer's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sameerahman24.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://sameerahman24.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://sameerahman24.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href="https://drive.google.com/file/d/1SuFUrEEZWXOxtCAdJXHKmv0iU6XpzuuU/view?usp=drive_link" title=Resume><span>Resume</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sameerahman24.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://sameerahman24.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Developing a Path Finding Algorithm for my game</h1><div class=post-meta><span title='2025-01-21 00:00:00 +0000 UTC'>January 21, 2025</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;Sameer Rahman</div></header><figure class=entry-cover><img loading=eager src=https://i.ibb.co/27BqpS51/399700642-21618d6f-d540-4dd8-bcea-03b7ee95c217.png alt="Pacman game picture"><figcaption>A snippet of the game..</figcaption></figure><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#introduction aria-label=Introduction>Introduction</a><ul><li><a href=#understanding-the-ghosts-movement aria-label="Understanding the Ghost’s Movement">Understanding the Ghost’s Movement</a></li><li><a href=#the-concept-of-manhattan-distance aria-label="The Concept of Manhattan Distance">The Concept of Manhattan Distance</a><ul><li><a href=#directions-array aria-label="Directions Array">Directions Array</a></li><li><a href=#the-pathfinding-method aria-label="The Pathfinding Method">The Pathfinding Method</a><ul><li><a href=#parameters aria-label=Parameters:>Parameters:</a></li><li><a href=#return-value aria-label="Return Value:">Return Value:</a></li></ul></li><li><a href=#movement-logic aria-label="Movement Logic">Movement Logic</a></li><li><a href=#supporting-methods aria-label="Supporting Methods">Supporting Methods</a></li><li><a href=#example-walkthrough aria-label="Example Walkthrough">Example Walkthrough</a></li><li><a href=#pros-and-cons-of-greedy-best-first-search aria-label="Pros and Cons of Greedy Best-First Search">Pros and Cons of Greedy Best-First Search</a><ul><li><a href=#pros aria-label=Pros:>Pros:</a></li><li><a href=#cons aria-label=Cons:>Cons:</a></li></ul></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li></ul></li></ul></div></details></div><div class=post-content><h1 id=introduction>Introduction<a hidden class=anchor aria-hidden=true href=#introduction>#</a></h1><p>I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the <strong>Greedy Best-First Search</strong>. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself.</p><h2 id=understanding-the-ghosts-movement>Understanding the Ghost’s Movement<a hidden class=anchor aria-hidden=true href=#understanding-the-ghosts-movement>#</a></h2><p>The ghost moves on a grid, where its primary goal is to either chase Pac-Man or, when scared, run away from him. To decide where to move next, the ghost needs to evaluate all possible directions and choose the best one. This is where pathfinding comes in. Specifically, the ghost evaluates its potential moves using a heuristic called the Manhattan Distance.</p><h2 id=the-concept-of-manhattan-distance>The Concept of Manhattan Distance<a hidden class=anchor aria-hidden=true href=#the-concept-of-manhattan-distance>#</a></h2><p>Manhattan Distance is a simple but effective way to measure the distance between two points on a grid. The term comes from the layout of streets in the Manhattan borough of New York, where streets are aligned in a grid pattern. In this system, the distance between two points is calculated by summing the absolute differences of their respective x and y coordinates.</p><p>For example, if the ghost is at position (2, 3) and Pac-Man is at (5, 5), the Manhattan Distance would be:</p><p>Horizontal distance = |5 - 2| = 3
Vertical distance = |5 - 3| = 2
Total Manhattan Distance = 3 + 2 = 5</p><h3 id=directions-array>Directions Array<a hidden class=anchor aria-hidden=true href=#directions-array>#</a></h3><p>The ghost can move up, down, left, or right and these options are represented as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[][]</span> DIRECTIONS <span style=color:#f92672>=</span> {{<span style=color:#f92672>-</span>1, 0}, {1, 0}, {0, <span style=color:#f92672>-</span>1}, {0, 1}};
</span></span></code></pre></div><ul><li><code>{-1, 0}</code>: Move up</li><li><code>{1, 0}</code>: Move down</li><li><code>{0, -1}</code>: Move left</li><li><code>{0, 1}</code>: Move right</li></ul><h3 id=the-pathfinding-method>The Pathfinding Method<a hidden class=anchor aria-hidden=true href=#the-pathfinding-method>#</a></h3><p>The main method that determines the ghost&rsquo;s movement is:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> <span style=color:#a6e22e>findBestPath</span>(<span style=color:#66d9ef>char</span><span style=color:#f92672>[][]</span> grid, <span style=color:#66d9ef>int</span> targetRow, <span style=color:#66d9ef>int</span> targetCol, <span style=color:#66d9ef>boolean</span> away)
</span></span></code></pre></div><h4 id=parameters>Parameters:<a hidden class=anchor aria-hidden=true href=#parameters>#</a></h4><ul><li><strong>grid</strong>: The game grid, which includes walls (&lsquo;W&rsquo;), (&lsquo;c&rsquo;) and (&lsquo;f)</li><li><strong>targetRow, targetCol</strong>: The position of the player</li><li><strong>away</strong>: A boolean that indicates if the ghost should move toward (false) or away from (true) the target.</li></ul><h4 id=return-value>Return Value:<a hidden class=anchor aria-hidden=true href=#return-value>#</a></h4><p>The best direction (e.g., <code>{1, 0}</code> for moving down), or null if no valid move is found.</p><h3 id=movement-logic>Movement Logic<a hidden class=anchor aria-hidden=true href=#movement-logic>#</a></h3><p>The ghost uses the Manhattan Distance to evaluate its moves. This heuristic calculates the distance to the target as:</p><p>For each direction:</p><ol><li>The ghost checks if moving in that direction is valid using <code>isValidMove</code>.</li><li>It calculates the Manhattan Distance from the potential new position to the target.</li><li>It selects the move with the smallest distance (to chase) or the largest distance (to run away).</li></ol><h3 id=supporting-methods>Supporting Methods<a hidden class=anchor aria-hidden=true href=#supporting-methods>#</a></h3><ul><li><strong>isValidMove</strong>: Ensures the ghost doesn’t move into walls or outside the grid boundaries.</li><li><strong>isCollidingWithGhost</strong>: Prevents ghosts from colliding with each other.</li><li><strong>updateGrid</strong>: Updates the game grid to reflect the ghost’s new position.</li></ul><h3 id=example-walkthrough>Example Walkthrough<a hidden class=anchor aria-hidden=true href=#example-walkthrough>#</a></h3><p>Let’s say the ghost is at (2, 3) and Pac-Man is at (5, 5):</p><p>The algorithm evaluates all possible moves:</p><ul><li>Up: (1, 3), distance = 6</li><li>Down: (3, 3), distance = 4</li><li>Left: (2, 2), distance = 6</li><li>Right: (2, 4), distance = 4</li></ul><p>If <code>away == false</code> (not scared), the ghost chooses the move with the smallest distance (Down or Right).</p><p>If <code>away == true</code> (scared), the ghost chooses the move with the largest distance (Up or Left).</p><h3 id=pros-and-cons-of-greedy-best-first-search>Pros and Cons of Greedy Best-First Search<a hidden class=anchor aria-hidden=true href=#pros-and-cons-of-greedy-best-first-search>#</a></h3><h4 id=pros>Pros:<a hidden class=anchor aria-hidden=true href=#pros>#</a></h4><ul><li><strong>Simplicity</strong>: The algorithm is easy to implement and computationally lightweight.</li><li><strong>Speed</strong>: Evaluating only four directions makes it fast, especially on small grids.</li></ul><h4 id=cons>Cons:<a hidden class=anchor aria-hidden=true href=#cons>#</a></h4><ul><li><strong>No Global Optimization</strong>: It doesn’t guarantee the shortest or most efficient path to the target.</li><li><strong>Heuristic Limitations</strong>: The Manhattan Distance works well for simple grids but may not handle complex obstacles effectively.</li></ul><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p><img alt="Game Over.." loading=lazy src=https://i.ibb.co/zV5B0Lzf/399700732-1df00077-5a6f-4c30-903c-68bc25f8341f.png>
The Greedy Best-First Search algorithm is an excellent choice for games like Pac-Man, where simplicity and responsiveness are key. It balances efficiency with functionality, allowing ghosts to behave dynamically without requiring heavy computations. By tweaking elements like the scare duration or movement randomness, developers can fine-tune ghost behavior for an engaging player experience.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sameerahman24.github.io/tags/projects/>Projects</a></li></ul><nav class=paginav><a class=prev href=https://sameerahman24.github.io/posts/m5microscope/><span class=title>« Prev</span><br><span>Using ESP32 camera module to take pictures </span></a><a class=next href=https://sameerahman24.github.io/posts/aboutme/><span class=title>Next »</span><br><span>About Me</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Developing a Path Finding Algorithm for my game on x" href="https://x.com/intent/tweet/?text=Developing%20a%20Path%20Finding%20Algorithm%20for%20my%20game&amp;url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fpathfinding%2f&amp;hashtags=Projects"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Developing a Path Finding Algorithm for my game on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fpathfinding%2f&amp;title=Developing%20a%20Path%20Finding%20Algorithm%20for%20my%20game&amp;summary=Developing%20a%20Path%20Finding%20Algorithm%20for%20my%20game&amp;source=https%3a%2f%2fsameerahman24.github.io%2fposts%2fpathfinding%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Developing a Path Finding Algorithm for my game on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsameerahman24.github.io%2fposts%2fpathfinding%2f&title=Developing%20a%20Path%20Finding%20Algorithm%20for%20my%20game"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>© Sameer Rahman</span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>