[{"content":"Introduction I recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well.\nIn this blog post, I’ll walk you through my custom ESP32 camera system, which allows remote image capture, LED indication, power management, and a simple web server interface. The system is built using an ESP32-based M5Stack TimerCAM module and leverages FreeRTOS tasks for efficient operation.\nFeatures Task-Based Image Capture: Runs a separate task for handling camera captures without blocking the main loop. Web Server: Allows users to capture images remotely and adjust camera settings. Power Management: Puts the ESP32 into deep sleep after inactivity to conserve power. Adjustable Camera Settings: Users can modify exposure and gain dynamically via web requests. Parallel Processing: Camera operations run on Core 0 while the main application logic (web server, WiFi, UI) runs on Core 1, enabling true parallelism. Non-blocking Operation: Ensures that the main application remains responsive during image capturing. Demo Pictures Hardware Requirements M5Stack TimerCAM (or similar ESP32 camera module) Power source (Battery or USB) LED for capture indication (optional) Code Breakdown 1. Camera Configuration Firstly, I needed to configure the pins correctly using the information available in the internet. I had to tinker a bit with settings like .jpeg_quality, .frame_size and .xclk_freq_hz to find the optimal settings for the camera to function with no bugs. This is because, when using a higher resolution with minimal compression (for example .jpeg_quality = 1) the images tend to have artifacts as there were both processing and memory challenges that the device could not keep up.\n#include \u0026lt;Arduino.h\u0026gt; #include \u0026#34;camera.h\u0026#34; #include \u0026lt;esp_camera.h\u0026gt; camera_config_t config = { .pin_pwdn = -1, // Not used on M5Stack Timer CAM .pin_reset = 15, // RESET pin .pin_xclk = 27, // XCLK pin .pin_sccb_sda = 25, // SDA pin .pin_sccb_scl = 23, // SCL pin .pin_d7 = 19, // Y9 pin .pin_d6 = 36, // Y8 pin .pin_d5 = 18, // Y7 pin .pin_d4 = 39, // Y6 pin .pin_d3 = 5, // Y5 pin .pin_d2 = 34, // Y4 pin .pin_d1 = 35, // Y3 pin .pin_d0 = 32, // Y2 pin .pin_vsync = 22, // VSYNC pin .pin_href = 26, // HREF pin .pin_pclk = 21, // PCLK pin .xclk_freq_hz = 20000000, // Frequency .ledc_timer = LEDC_TIMER_0, .ledc_channel = LEDC_CHANNEL_0, .pixel_format = PIXFORMAT_JPEG, .frame_size = FRAMESIZE_UXGA, // Resolution of image .jpeg_quality = 3, // Compression level (higher = more compression) .fb_count = 1, // Number of frame buffers in memory .grab_mode = CAMERA_GRAB_LATEST }; The problem was even more evident before I implemented multi-threading. I had to use lower camera settings to take pictures.\nThat is why I implemented it to make the camera task run separately on Core 0, handling image capture requests asynchronously. This ensures that everything else can run smoothly on Core 1. This fixed issues like sudden connection losses and crashed.\nvoid cameraTask(void *parameter) { while (true) { if (captureRequested \u0026amp;\u0026amp; !captureInProgress) { captureInProgress = true; capturedFrame = esp_camera_fb_get(); captureRequested = false; captureInProgress = false; if (capturedFrame) { xSemaphoreGive(frameReadySemaphore); } } vTaskDelay(5 / portTICK_PERIOD_MS); } } 2. Web Server for Remote Access In this section, the ESP32 sets up a web server that listens on port 80, allowing remote devices to send HTTP requests to control the camera. The core function, handleCapture(), is responsible for initiating an image capture when a client accesses the /capture endpoint. Once the image is captured using our task-based method, it sends the JPEG image data as an HTTP response.\n#include \u0026lt;WiFi.h\u0026gt; #include \u0026lt;ESPAsyncWebServer.h\u0026gt; #include \u0026#34;camera.h\u0026#34; AsyncWebServer server(80); void handleCapture(AsyncWebServerRequest *request) { camera_fb_t *fb = captureImage(); if (!fb) { request-\u0026gt;send(500, \u0026#34;text/plain\u0026#34;, \u0026#34;Camera capture failed\u0026#34;); return; } request-\u0026gt;send(200, \u0026#34;image/jpeg\u0026#34;, fb-\u0026gt;buf, fb-\u0026gt;len); } The image can then be viewed and saved into the device from the web browser.\n3. Power Management Another problem I was facing was battery life. At most the device lasted for around 20 minutes. To extend battery life, the system monitors activity by seeing when was the last time /capture endpoint was accessed and enters deep sleep if it hasn\u0026rsquo;t been accessed in more than 3 minutes.\n#include \u0026#34;power.h\u0026#34; #include \u0026lt;esp_sleep.h\u0026gt; unsigned long lastCaptureTime = 0; const unsigned long inactivityTimeout = 180000; void checkInactivity() { if (millis() - lastCaptureTime \u0026gt;= inactivityTimeout) { Serial.println(\u0026#34;Entering deep sleep...\u0026#34;); esp_deep_sleep_start(); } } 4. Setting Up the Web Interface The ESP32 also serves a user-friendly HTML page stored in SPIFFS, which acts as the control panel for the camera. When a client navigates to the root URL (/), the server checks for the existence of an index.html file. If found, it sends the HTML content to the client; otherwise, it returns a 404 error. This HTML interface includes various elements such as a status panel, image display, and controls (buttons and sliders) to capture images, update camera settings, and even trigger deep sleep.\nserver.on(\u0026#34;/\u0026#34;, HTTP_GET, [](AsyncWebServerRequest *request){ if (SPIFFS.exists(\u0026#34;/index.html\u0026#34;)) { request-\u0026gt;send(SPIFFS, \u0026#34;/index.html\u0026#34;, \u0026#34;text/html\u0026#34;); } else { request-\u0026gt;send(404, \u0026#34;text/plain\u0026#34;, \u0026#34;File not found\u0026#34;); } }); 5. Web Interface Design and Functionality The web interface is designed to provide a user-friendly experience for capturing images and adjusting camera settings. It consists of:\nA status panel displaying IP address, battery level, and countdown timer before shutdown. An image container that shows the captured image. A control panel with sliders for exposure and gain adjustment. A capture button to trigger image capture remotely. A sleep button to put the device into deep sleep manually. The interface dynamically updates battery level and countdown timer using JavaScript, making periodic requests to the ESP32 server. Users can modify exposure and gain using sliders, and the settings are applied instantly upon clicking the update button.\nConclusion While working on this I have learned a lot. From C++ to multithreading, this project has been quite rewarding. This project has helped me develop skills like problem solving and communication skills that I developed working with my supervisor in the lab.\n","permalink":"https://sameerahman24.github.io/posts/m5microscope/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eI recently got an internship where I was tasked to program a microcontroller, specifically ESP32-based M5TimerCamera. The camera is connected to an external lens and is used as a microscope to display the images taken onto a smartphone device. By joining the WiFi access point of the M5Camera and going to the IP address from the browser, images can be captured by clicking a button. Furthermore, specific settings like exposure and gain values can be changed from the web browser as well.\u003c/p\u003e","title":"Building a Web-Controlled ESP32 Microscope: Remote Imaging with M5TimerCamera"},{"content":"Introduction I was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the Greedy Best-First Search. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself.\nUnderstanding the Ghost’s Movement The ghost moves on a grid, where its primary goal is to either chase Pac-Man or, when scared, run away from him. To decide where to move next, the ghost needs to evaluate all possible directions and choose the best one. This is where pathfinding comes in. Specifically, the ghost evaluates its potential moves using a heuristic called the Manhattan Distance.\nThe Concept of Manhattan Distance Manhattan Distance is a simple but effective way to measure the distance between two points on a grid. The term comes from the layout of streets in the Manhattan borough of New York, where streets are aligned in a grid pattern. In this system, the distance between two points is calculated by summing the absolute differences of their respective x and y coordinates.\nFor example, if the ghost is at position (2, 3) and Pac-Man is at (5, 5), the Manhattan Distance would be:\nHorizontal distance = |5 - 2| = 3 Vertical distance = |5 - 3| = 2 Total Manhattan Distance = 3 + 2 = 5\nDirections Array The ghost can move up, down, left, or right and these options are represented as:\nprivate static final int[][] DIRECTIONS = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; {-1, 0}: Move up {1, 0}: Move down {0, -1}: Move left {0, 1}: Move right The Pathfinding Method The main method that determines the ghost\u0026rsquo;s movement is:\nprivate int[] findBestPath(char[][] grid, int targetRow, int targetCol, boolean away) Parameters: grid: The game grid, which includes walls (\u0026lsquo;W\u0026rsquo;), (\u0026lsquo;c\u0026rsquo;) and (\u0026lsquo;f) targetRow, targetCol: The position of the player away: A boolean that indicates if the ghost should move toward (false) or away from (true) the target. Return Value: The best direction (e.g., {1, 0} for moving down), or null if no valid move is found.\nMovement Logic The ghost uses the Manhattan Distance to evaluate its moves. This heuristic calculates the distance to the target as:\nFor each direction:\nThe ghost checks if moving in that direction is valid using isValidMove. It calculates the Manhattan Distance from the potential new position to the target. It selects the move with the smallest distance (to chase) or the largest distance (to run away). Supporting Methods isValidMove: Ensures the ghost doesn’t move into walls or outside the grid boundaries. isCollidingWithGhost: Prevents ghosts from colliding with each other. updateGrid: Updates the game grid to reflect the ghost’s new position. Example Walkthrough Let’s say the ghost is at (2, 3) and Pac-Man is at (5, 5):\nThe algorithm evaluates all possible moves:\nUp: (1, 3), distance = 6 Down: (3, 3), distance = 4 Left: (2, 2), distance = 6 Right: (2, 4), distance = 4 If away == false (not scared), the ghost chooses the move with the smallest distance (Down or Right).\nIf away == true (scared), the ghost chooses the move with the largest distance (Up or Left).\nPros and Cons of Greedy Best-First Search Pros: Simplicity: The algorithm is easy to implement and computationally lightweight. Speed: Evaluating only four directions makes it fast, especially on small grids. Cons: No Global Optimization: It doesn’t guarantee the shortest or most efficient path to the target. Heuristic Limitations: The Manhattan Distance works well for simple grids but may not handle complex obstacles effectively. Conclusion The Greedy Best-First Search algorithm is an excellent choice for games like Pac-Man, where simplicity and responsiveness are key. It balances efficiency with functionality, allowing ghosts to behave dynamically without requiring heavy computations. By tweaking elements like the scare duration or movement randomness, developers can fine-tune ghost behavior for an engaging player experience.\n","permalink":"https://sameerahman24.github.io/posts/pathfinding/","summary":"\u003ch1 id=\"introduction\"\u003eIntroduction\u003c/h1\u003e\n\u003cp\u003eI was creating a game inspired from Pacman to brush up my coding skills that I learnt on the first semester of college only to come across a road block. How will the ghosts track the player and move towards you? The solution I used is the \u003cstrong\u003eGreedy Best-First Search\u003c/strong\u003e. Now before we dive into it we must first familiarize ourselves with how the ghosts move in the game itself.\u003c/p\u003e","title":"Making Pacman way harder than it needs to be"},{"content":"The Start Hello, my name is Sameer, and this is the beginning of my new blog. I\u0026rsquo;m currently studying at Case Western Reserve University. I’m enthusiastic about tech and love learning new skills and this blog will be a space where I share my journey, projects, and the latest skills I’ve picked up.\nFeel free to follow along, and if you have any questions, don’t hesitate to reach out to me via email.\nMy Socials Here are my socials where you can connect with me:\nLinkedIn YouTube ","permalink":"https://sameerahman24.github.io/posts/aboutme/","summary":"\u003ch2 id=\"the-start\"\u003eThe Start\u003c/h2\u003e\n\u003cp\u003eHello, my name is \u003cstrong\u003eSameer\u003c/strong\u003e, and this is the beginning of my new blog. I\u0026rsquo;m currently studying at \u003cstrong\u003eCase Western Reserve University\u003c/strong\u003e. I’m enthusiastic about tech and love learning new skills and this blog will be a space where I share my journey, projects, and the latest skills I’ve picked up.\u003c/p\u003e\n\u003cp\u003eFeel free to follow along, and if you have any questions, don’t hesitate to reach out to me via email.\u003c/p\u003e","title":"About Me"},{"content":"","permalink":"https://sameerahman24.github.io/tags/","summary":"Browse posts by tags.","title":"Tags"}]